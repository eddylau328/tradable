from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import Http404, HttpResponseForbidden
from django.shortcuts import render
from django.urls import reverse
from django.views.generic.edit import FormMixin

from django.views.generic import DetailView, ListView

from .forms import ComposeForm
from .models import Thread, ChatMessage

# There are two situations when directing to the message view page.
# The first one is by clicking the message button at the top navigation menu.
# The second one is by clicking the buy button in the item dynamic look up view.
# The first one does not need to render the thread view.
# The second one needed to render the thread view, which is related to the seller and the selected item.
# Therefore, it needs to check whether it needs to render the corresponding thread view or not.


def MessagesView(request, **kwargs):
    seller = ""
    item_id = ""
    # The item_dynamic_lookup_view will redirect the buyer to the message view, and at the same time send the corresponding data by session. Therefore, it is used to distinguish whether the thread view needs to be render or not. In the function, it used if-else to check the data is here or not.
    if ('seller' in request.session):
        seller = request.session['seller']
        del request.session['seller']
    else:
        seller = None
    if ('item_id' in request.session):
        item_id = request.session['item_id']
        del request.session['item_id']
    else:
        item_id = None
    sellerContext = {
        'seller': seller,
        'item_id': item_id
    }
    return render(request, "chat/message.html", sellerContext)


class InboxView(LoginRequiredMixin, ListView):
    template_name = 'chat/inbox.html'
    # rendering the current chat rooms that a user has

    def get_queryset(self):
        return Thread.objects.by_user(self.request.user)


# returning the thread object to the frontend and receiving the POST function from the frontend.
class ThreadView(LoginRequiredMixin, FormMixin, DetailView):
    template_name = 'chat/thread.html'
    form_class = ComposeForm
    success_url = './'

    def get_queryset(self):
        return Thread.objects.by_user(self.request.user)

    def get_object(self):
        other_username = self.kwargs.get("username")
        itemID = self.kwargs.get("itemID")
        # find the thread object by searching with the username and the item id. If the thread object cannot be found or created, it will generate a 404 error.
        obj, created = Thread.objects.get_or_new(self.request.user, other_username, itemID)
        if obj == None:
            raise Http404
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = self.get_form()
        return context

    # it process when the thread view receives a POST.
    def post(self, request, *args, **kwargs):
        # The POST is generated by the user submitting the message.
        if not request.user.is_authenticated:
            return HttpResponseForbidden()

        self.object = self.get_object()
        form = self.get_form()
        # After receiving the POST, it will check the whether it is valid or not, and then proceed to the form_valid() function
        if form.is_valid():
            return self.form_valid(form)
        else:
            return self.form_invalid(form)

    # it will create a new message and save it
    def form_valid(self, form):
        thread = self.get_object()
        user = self.request.user
        message = form.cleaned_data.get("message")
        ChatMessage.objects.create(user=user, thread=thread, message=message)
        return super().form_valid(form)
